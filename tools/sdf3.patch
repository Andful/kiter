Only in sdf3/sdf3/build: release
Only in sdf3/sdf3/build: work
Only in sdf3/sdf3/csdf/analysis/buffersizing: #buffer.cc#
diff -crB ../sdf3/sdf3/csdf/analysis/buffersizing/buffer.cc sdf3/sdf3/csdf/analysis/buffersizing/buffer.cc
*** ../sdf3/sdf3/csdf/analysis/buffersizing/buffer.cc	2014-07-24 12:16:04.000000000 +0800
--- sdf3/sdf3/csdf/analysis/buffersizing/buffer.cc	2021-01-21 15:26:47.935610418 +0800
***************
*** 37,44 ****
--- 37,62 ----
  
  #include "buffer.h"
  #include "../throughput/throughput.h"
+ // libraries for data logging
+ #include <chrono>
+ // define variables to toggle verbose/extremely verbose/logging
+ // #define VERBOSE_OUT // print out explored storage distributions and results
+ // #define DEPS_OUT // extremely verbose output --- useful for understanding implementation of symbolic execution and storage deps
+ #define LOG_OUT // log data of DSE in CSVs
+ 
  namespace CSDF
  {
+   #ifdef VERBOSE_OUT
+   long int computation_counter = 0;
+   #endif
+   // variables for data logging
+   #ifdef LOG_OUT
+   string dirName = std::getenv("SDF3LOGDIR");
+   string logDirName = "dse_logs/";
+   string ppDirName = "pp_logs/";
+   ofstream dseLog; // save search path data in DSE log
+   std::chrono::duration<double, milli> cumulativeTime;
+   #endif
  
      /******************************************************************************
       * Bounds on the search space
***************
*** 62,67 ****
--- 80,88 ----
       */
      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
      {
+       #ifdef VERBOSE_OUT
+       cout << "Calculating minimal channel step sizes..." << endl;
+       #endif
          minSzStep = new TBufSize [g->nrChannels()];
  
          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
***************
*** 84,89 ****
--- 105,114 ----
                  minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
  
              minSzStep[ch->getId()] = minStepSz;
+ 	    #ifdef VERBOSE_OUT
+ 	    cout << "Min. step size for channel " << ch->getName() << ": "
+ 		 << minStepSz << endl;
+ 	    #endif
          }
      }
  
***************
*** 93,98 ****
--- 118,126 ----
       */
      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
      {
+       #ifdef VERBOSE_OUT
+       cout << "Calculating minimal channel sizes (for positive throughput)..." << endl;
+       #endif
          minSz =  new TBufSize [g->nrChannels()];
  
          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
***************
*** 116,121 ****
--- 144,152 ----
                  uint t = ch->getInitialTokens();
                  uint lb;
  
+ 		#ifdef VERBOSE_OUT
+ 		cout << "p, c, t: " << p << ", " << c << ", " << t << endl;
+ 		#endif
                  // Lower-bound of a self-edge is rate at which data is produced and
                  // consumed and the number of initial tokens present
                  if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
***************
*** 134,139 ****
--- 165,174 ----
                  if (lb < minSz[ch->getId()])
                      minSz[ch->getId()] = lb;
              }
+ 	    #ifdef VERBOSE_OUT
+ 	    cout << "Minimum channel size for " << ch->getName() << ": "
+ 		 << minSz[ch->getId()] << endl;
+ 	    #endif
          }
      }
  
***************
*** 147,152 ****
--- 182,190 ----
  
          for (uint c = 0; c < g->nrChannels(); c++)
              lbDistributionSz += minSz[c];
+ 	#ifdef VERBOSE_OUT
+ 	cout << "Lower bound distribution size: " << lbDistributionSz << endl;
+ 	#endif
      }
  
      /**
***************
*** 158,163 ****
--- 196,204 ----
          CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
  
          maxThroughput = thrAnalysisAlgo.analyze(g);
+ 	#ifdef VERBOSE_OUT
+ 	cout << "Max throughput: " << maxThroughput << endl;
+ 	#endif
      }
  
      /******************************************************************************
***************
*** 350,356 ****
              // Time between previous state
              time += s.glbClk;
          }
! 
          return (TDtime)(nr_fire) / (time);
      }
  
--- 391,402 ----
              // Time between previous state
              time += s.glbClk;
          }
! 	#ifdef DEPS_OUT
! 	cout << "\nComputing throughput..."
! 	     << "\nNumber of executions: " << nr_fire
! 	     << "\nPeriod length: " << time
! 	     << endl;
! 	#endif
          return (TDtime)(nr_fire) / (time);
      }
  
***************
*** 382,387 ****
--- 428,437 ----
                  if (color[b] == 1)
                  {
                      // Found a cycle in the graph containing node b
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\t\t\t\t Found cycle in abstract dep graph containing node from actor "
+ 		       << g->getActor(a)->getName() << " and actor " << g->getActor(b)->getName() << endl;
+ 		  #endif
                      c = a;
                      d = b;
                      do
***************
*** 396,402 ****
--- 446,457 ----
                              CId dstId = ch->getDstActor()->getId();
  
                              if (dstId == d && srcId == c)
+ 			      {
+ 				#ifdef DEPS_OUT
+ 				cout << "\t\t\t\t  Storage dependency found in channel " << ch->getName() << endl;
+ 				#endif
                                  dep[ch->getId()] = true;
+ 			      }
                          }
  
                          // Next
***************
*** 520,525 ****
--- 575,583 ----
      void CSDFstateSpaceBufferAnalysis::TransitionSystem::startActorFiring(
          TimedCSDFactor *a)
      {
+       #ifdef DEPS_OUT
+       cout << "Start firing of actor " << a->getName() << endl;
+       #endif
          // Consume tokens from inputs and space for output tokens
          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
          {
***************
*** 529,548 ****
              // Actor is destination of the channel?
              if (p->getType() == CSDFport::In)
              {
                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
              }
              else
              {
!                 CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
              }
          }
  
          // Add actor firing to the list of active firings of this actor
          currentState.actClk[a->getId()].push_back(
              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
  
          // Advance the sequence position of the actor
          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
      }
  
      /**
--- 587,623 ----
              // Actor is destination of the channel?
              if (p->getType() == CSDFport::In)
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "\tConsume " << p->getRate()[ACT_SEQ_POS(a->getId())]
+ 		   << " tokens from channel " << c->getName() << endl;
+ 	      #endif
                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
              }
              else
              {
! 	      #ifdef DEPS_OUT
! 	      cout << "\tSpace in channel " << c->getName() << " reduced by "
! 		   << p->getRate()[ACT_SEQ_POS(a->getId())] << endl;
! 	      #endif
! 	      CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
              }
          }
  
          // Add actor firing to the list of active firings of this actor
          currentState.actClk[a->getId()].push_back(
              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\tAdd actor firing to list of active firings of actor:" << endl;
+ 	cout << "\t\tExecution time of " << a->getExecutionTime()[ACT_SEQ_POS(a->getId())]
+ 	     << " added" << endl;
+ 	#endif
  
          // Advance the sequence position of the actor
          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\tActor is now in phase " << ACT_SEQ_POS(a->getId()) << endl;
+ 	currentState.print(cout);
+ 	#endif
      }
  
      /**
***************
*** 571,576 ****
--- 646,654 ----
      void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
          CSDFactor *a)
      {
+       #ifdef DEPS_OUT
+       cout << "End firing of actor " << a->getName() << endl;
+       #endif
          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
          {
              CSDFport *p = *iter;
***************
*** 584,599 ****
              // Actor is source of the channel?
              if (p->getType() == CSDFport::Out)
              {
!                 PRODUCE(c->getId(), p->getRate()[seqPos]);
              }
              else
              {
                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
              }
          }
  
          // Remove the firing from the list of active actor firings
          currentState.actClk[a->getId()].pop_front();
      }
  
      /**
--- 662,689 ----
              // Actor is source of the channel?
              if (p->getType() == CSDFport::Out)
              {
! 	      #ifdef DEPS_OUT
! 	      cout << "\tProduce " << p->getRate()[seqPos]
! 		   << " tokens into channel " << c->getName() << endl;
! 	      #endif
! 	      PRODUCE(c->getId(), p->getRate()[seqPos]);
              }
              else
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "\tSpace in channel " << c->getName() << " increased by "
+ 		   << p->getRate()[seqPos] << endl;
+ 	      #endif
                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
              }
          }
  
          // Remove the firing from the list of active actor firings
          currentState.actClk[a->getId()].pop_front();
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\tRemove actor firing to list of active firings of actor" << endl;
+         currentState.print(cout);
+ 	#endif
      }
  
      /**
***************
*** 669,674 ****
--- 759,775 ----
                  if (!CH_TOKENS_PREV(c->getId(),
                                      p->getRate()[ACT_SEQ_POS(a->getId())]))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+ 		       << ": not enough tokens in previous state (needed at least "
+ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " tokens)" << endl;
+ 		  cout << "Previous state:" << endl;
+ 		  previousState.print(cout);
+ 		  cout << endl;
+ 		  cout << "Current state:" << endl;
+ 		  currentState.print(cout);
+ 		  cout << endl;
+ 		  #endif
                      abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
                  }
              }
***************
*** 678,683 ****
--- 779,795 ----
                  if (!CH_SPACE_PREV(c->getId(),
                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+ 		       << ": not enough space in previous state (needed at least "
+ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " space)" << endl;
+ 		  cout << "Previous state:" << endl;
+ 		  previousState.print(cout);
+ 		  cout << endl;
+ 		  cout << "Current state:" << endl;
+ 		  currentState.print(cout);
+ 		  cout << endl;
+ 		  #endif
                      abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
                  }
              }
***************
*** 708,733 ****
              for (uint j = 0; j < g->nrActors(); j++)
                  abstractDepGraph[i][j] = false;
          }
  
          // Start new iteration of the periodic phase
          currentState.glbClk = 0;
  
          // Still need to complete the last firing of the output actor
          // before period really ends
!         repCnt = -1;
  
          // Complete the remaining actor firings
          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
          {
              CSDFactor *a = *iter;
  
              while (actorReadyToEnd(a))
              {
                  if (a->getId() == outputActor->getId())
                  {
                      repCnt++;
                      if (repCnt == outputActorRepCnt)
                      {
                          currentState.glbClk = 0;
                          repCnt = 0;
                      }
--- 820,865 ----
              for (uint j = 0; j < g->nrActors(); j++)
                  abstractDepGraph[i][j] = false;
          }
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\t\tAbstract dependency graph initialised" << endl;
+ 	#endif
  
          // Start new iteration of the periodic phase
          currentState.glbClk = 0;
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\t\tReset global clock for new iteration of periodic phase:" << endl;
+ 	currentState.print(cout);
+ 	#endif
  
          // Still need to complete the last firing of the output actor
          // before period really ends
!         repCnt = -1; // so that output actor is executed one more time
  
          // Complete the remaining actor firings
+ 	#ifdef DEPS_OUT
+ 	cout << "\t\t\tCompleting remaining actor firings" << endl;
+ 	#endif
          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
          {
              CSDFactor *a = *iter;
  
              while (actorReadyToEnd(a))
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
+ 	      #endif
                  if (a->getId() == outputActor->getId())
                  {
                      repCnt++;
+ 		    #ifdef DEPS_OUT
+ 		    cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+ 			 << repCnt << endl;
+ 		    #endif
                      if (repCnt == outputActorRepCnt)
                      {
+ 		      #ifdef DEPS_OUT
+ 		      cout << "\t\t\trepCnt equal to outputActorRepCnt: reset currentState.glbClk and repCnt to 0" << endl;
+ 		      #endif
                          currentState.glbClk = 0;
                          repCnt = 0;
                      }
***************
*** 749,754 ****
--- 881,890 ----
                  // Ready to fire actor a?
                  while (actorReadyToFire(a))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to fire" << endl;
+ 		  cout << "\t\t\tFind causal dependencies for this actor" << endl;
+ 		  #endif
                      // Track causal dependencies on firing of actor a
                      findCausalDependencies(a, abstractDepGraph);
  
***************
*** 760,765 ****
--- 896,904 ----
              // Clock step
              clockStep();
  
+ 	    #ifdef DEPS_OUT
+ 	    cout << "\t\t\tStoring partial state by setting current state ch and sp to prev state" << endl;
+ 	    #endif
              // Store partial state to check for progress
              for (uint i = 0; i < g->nrChannels(); i++)
              {
***************
*** 768,773 ****
--- 907,915 ----
              }
  
              // Finish actor firings
+ 	    #ifdef DEPS_OUT
+ 	    cout << "\t\t\tFinish actor firings" << endl;
+ 	    #endif
              for (CSDFactorsIter iter = g->actorsBegin();
                   iter != g->actorsEnd(); iter++)
              {
***************
*** 775,788 ****
--- 917,944 ----
  
                  while (actorReadyToEnd(a))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
+ 		  #endif
                      if (outputActor->getId() == a->getId())
                      {
                          repCnt++;
+ 			#ifdef DEPS_OUT
+ 			cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+ 			     << repCnt << endl;
+ 			#endif
                          if (repCnt == outputActorRepCnt)
                          {
+ 			  #ifdef DEPS_OUT
+ 			  cout << "\t\t\trepCnt equal to outputActorRepCnt:" << endl;
+ 			  #endif
                              // Found periodic state
                              if (currentState == periodicState)
                              {
+ 			      #ifdef DEPS_OUT
+ 			      cout << "\t\t\tCurrent state is the periodic state" << endl;
+ 			      cout << "\t\t\t\tLook for storage dependencies (cycles in abstract dependency graph)" << endl;
+ 			      #endif
                                  // Cycles in the dependency graph indicate storage
                                  // dependencies
                                  findStorageDependencies(abstractDepGraph, dep);
***************
*** 795,800 ****
--- 951,959 ----
                                  // Done
                                  return;
                              }
+ 			    #ifdef DEPS_OUT
+ 			    cout << "Reset currentState.glbClk and repCnt to 0" << endl;
+ 			    #endif
                              currentState.glbClk = 0;
                              repCnt = 0;
                          }
***************
*** 824,829 ****
--- 983,991 ----
              for (uint j = 0; j < g->nrActors(); j++)
                  abstractDepGraph[i][j] = false;
          }
+ 	#ifdef DEPS_OUT
+ 	cout << "\tAbstract dependency graph initialised" << endl;
+ 	#endif
  
          // Check number of tokens on every channel in the graph
          for (CSDFchannelsIter iter = g->channelsBegin();
***************
*** 837,842 ****
--- 999,1010 ----
              if (!CH_TOKENS(c->getId(),
                             c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
+ 		   << ": not enough tokens to fire destination actor " << dstActor->getName()
+ 		   << " (needed at least " << c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+ 		   << " tokens)" << endl;
+ 	      #endif
                  abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
              }
  
***************
*** 844,849 ****
--- 1012,1023 ----
              if (!CH_SPACE(c->getId(),
                            c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
+ 		   << ": not enough space to fire source actor " << srcActor->getName()
+ 		   << " (needed at least " << c->getSrcPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+ 		   << " space)" << endl;
+ 	      #endif
                  abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
              }
          }
***************
*** 873,878 ****
--- 1047,1056 ----
          clearStoredStates();
  
          // Create initial state
+ 	#ifdef DEPS_OUT
+ 	cout << "Initialising previous and current states with " << to_string(g->nrActors())
+ 	     << " actors and " << to_string(g->nrChannels()) << " channels" << endl;
+ 	#endif
          currentState.init(g->nrActors(), g->nrChannels());
          currentState.clear();
          previousState.init(g->nrActors(), g->nrChannels());
***************
*** 891,901 ****
--- 1069,1090 ----
                  return 0;
              }
  
+ 	    #ifdef DEPS_OUT
+ 	    cout << "Setting initial tokens and space for channel: " << c->getName() << " ("
+ 		 << c->getInitialTokens() << ", " << sp[c->getId()] - c->getInitialTokens()
+ 		 << ")" << endl;
+ 	    #endif
              CH(c->getId()) = c->getInitialTokens();
              SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
+ 	    #ifdef DEPS_OUT
+ 	    c->print(cout);
+ 	    #endif
          }
  
          // Fire the actors
+ 	#ifdef DEPS_OUT
+ 	cout << "\nBegin actor firings" << endl;
+ 	#endif
          while (true)
          {
              // Store partial state to check for progress
***************
*** 913,927 ****
  
                  while (actorReadyToEnd(a))
                  {
                      if (outputActor->getId() == a->getId())
                      {
                          repCnt++;
                          if (repCnt == outputActorRepCnt)
                          {
                              // Add state to hash of visited states
                              if (!storeState(currentState, recurrentState))
                              {
!                                 // Find storage dependencies in periodic phase
                                  analyzePeriodicPhase(sp, dep);
  
                                  return computeThroughput(recurrentState);
--- 1102,1129 ----
  
                  while (actorReadyToEnd(a))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\nActor " << a->getName() << " ready to end...." << endl;
+ 		  #endif
                      if (outputActor->getId() == a->getId())
                      {
                          repCnt++;
+ 			#ifdef DEPS_OUT
+ 			cout << "\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+ 			     << repCnt << endl;
+ 			#endif
                          if (repCnt == outputActorRepCnt)
                          {
+ 			  #ifdef DEPS_OUT
+ 			  cout << "\t\trepCnt equal to outputActorRepCnt" << endl;
+ 			  #endif
                              // Add state to hash of visited states
                              if (!storeState(currentState, recurrentState))
                              {
! 			      // Find storage dependencies in periodic phase
! 			      #ifdef DEPS_OUT
! 			      cout << "\t\tCurrent state has been visited before: analyse periodic phase" << endl;
! 			      #endif
                                  analyzePeriodicPhase(sp, dep);
  
                                  return computeThroughput(recurrentState);
***************
*** 945,950 ****
--- 1147,1155 ----
                  // Ready to fire actor a?
                  while (actorReadyToFire(a))
                  {
+ 		  #ifdef DEPS_OUT
+ 		  cout << "\nActor " << a->getName() << " ready to fire" << endl;
+ 		  #endif
                      // Fire actor a
                      startActorFiring(a);
                  }
***************
*** 952,961 ****
--- 1157,1172 ----
  
              // Clock step
              clkStep = clockStep();
+ 	    #ifdef DEPS_OUT
+ 	    cout << "clkStep set to " << clkStep << endl;
+ 	    #endif
  
              // Deadlocked?
              if (clkStep == UINT_MAX)
              {
+ 	      #ifdef DEPS_OUT
+ 	      cout << "clkStep too high, deadlock found: analyse deadlock" << endl;
+ 	      #endif
                  // Find cause of deadlock
                  analyzeDeadlock(sp, dep);
                  return 0;
***************
*** 1007,1020 ****
          // Initialize blocking channels
          for (uint c = 0; c < g->nrChannels(); c++)
              d->dep[c] = false;
! 
          // Execute the CSDF graph to find its output interval
          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
! 
          //cerr << d->sz << " " << d->thr << endl;
          //for (uint c = 0; c < g->nrChannels(); c++)
          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
          //cerr << endl;
      }
  
      /**
--- 1218,1270 ----
          // Initialize blocking channels
          for (uint c = 0; c < g->nrChannels(); c++)
              d->dep[c] = false;
! 	
          // Execute the CSDF graph to find its output interval
          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
! 	
          //cerr << d->sz << " " << d->thr << endl;
          //for (uint c = 0; c < g->nrChannels(); c++)
          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
          //cerr << endl;
+ 
+ 	#ifdef VERBOSE_OUT
+ 	cout << "\tCurrent StorageDistribution info:" << endl;
+ 	cout << "\tNumber of edges: " << g->nrChannels() << endl;
+ 	cout << "\tChannel quantities:\n\t";
+ 	for (CSDFchannelsIter iter = g->channelsBegin();
+ 	     iter != g->channelsEnd(); iter++) {
+ 	  CSDFchannel *c = *iter;
+ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+ 	    cout << d->sp[c->getId()] << " ";
+ 	  }
+ 	}
+ 	cout << endl;
+ 	cout << "\tDistribution size: " << d->sz << endl;
+ 	cout << "\tThroughput: " << d->thr << endl;
+ 	cout << endl;
+ 	#endif
+ 
+ 	#ifdef LOG_OUT
+ 	// log dse data
+ 	string output("\"");
+ 	string delim("");
+ 	uint noFeedbackSize = 0;	
+ 	for (CSDFchannelsIter iter = g->channelsBegin();
+ 	     iter != g->channelsEnd(); iter++) {
+ 	  CSDFchannel *c = *iter;
+ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+ 	    output += delim;
+ 	    output += to_string(d->sp[c->getId()]);
+ 	    delim = ",";
+ 	    noFeedbackSize += d->sp[c->getId()];
+ 	  }
+ 	}
+ 	output += "\"";
+ 	
+ 	dseLog << noFeedbackSize << "," // distribution size
+ 	       << d->thr << "," // throughput
+ 	       << output << ","; // channel quantities
+ 	#endif
      }
  
      /**
***************
*** 1032,1037 ****
--- 1282,1291 ----
          // throughput with previous (smaller) distribution size
          if (ds->prev != NULL && ds->prev->thr == ds->thr)
          {
+ 	  #ifdef VERBOSE_OUT
+ 	  cout << "\t\tNew storage distribution set of dist size " << ds->sz
+ 	       << " found to be non-minimal: removing from set" << endl;
+ 	  #endif
              // No minimal storage distributions exist in this list
              // Iterate over the list of storage distributions
              d = ds->distributions;
***************
*** 1072,1077 ****
--- 1326,1335 ----
                      t = d->next;
  
                      // Cleanup d
+ 		    #ifdef VERBOSE_OUT
+ 		    cout << "\t\tStorage distribution of size " << d->sz
+ 			 << " found to be non-minimal: removing from set" << endl;
+ 		    #endif
                      deleteStorageDistribution(d);
  
                      // Next
***************
*** 1102,1110 ****
--- 1360,1375 ----
          StorageDistribution *di;
          bool equalDistr;
  
+ 	#ifdef VERBOSE_OUT
+ 	cout << "\t\tAttempting to add storage distribution of dist sz: " << d->sz
+ 	     << " to set" << endl;
+ 	#endif
          // First distribution ever added?
          if (minStorageDistributions == NULL)
          {
+ 	  #ifdef VERBOSE_OUT
+ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+ 	  #endif
              // Create new set of storage distributions
              dsNew = new StorageDistributionSet;
              dsNew->sz = d->sz;
***************
*** 1147,1160 ****
                  }
  
                  // Found equal distribution
!                 if (equalDistr)
!                     return false;
  
                  // Next
                  di = di->next;
              }
  
              // Distribution 'd' not yet in the set, so let's add it
              ds->distributions->prev = d;
              d->next = ds->distributions;
              ds->distributions = d;
--- 1412,1432 ----
                  }
  
                  // Found equal distribution
!                 if (equalDistr) {
! 		  #ifdef VERBOSE_OUT
! 		  cout << "\t\t\tFound matching distribution: not adding new distribution" << endl;
! 		  #endif
! 		  return false;
! 		}
  
                  // Next
                  di = di->next;
              }
  
              // Distribution 'd' not yet in the set, so let's add it
+ 	    #ifdef VERBOSE_OUT
+ 	    cout << "\t\t\tNew storage distribution added!" << endl;
+ 	    #endif
              ds->distributions->prev = d;
              d->next = ds->distributions;
              ds->distributions = d;
***************
*** 1162,1168 ****
          else if (ds->next == NULL)
          {
              // No set of distribution in the list with same or larger size?
! 
              // Create new set of storage distributions
              dsNew = new StorageDistributionSet;
              dsNew->sz = d->sz;
--- 1434,1442 ----
          else if (ds->next == NULL)
          {
              // No set of distribution in the list with same or larger size?
! 	  #ifdef VERBOSE_OUT
! 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
! 	  #endif
              // Create new set of storage distributions
              dsNew = new StorageDistributionSet;
              dsNew->sz = d->sz;
***************
*** 1182,1187 ****
--- 1456,1464 ----
              // distribution 'd'.
  
              // Create new set of storage distributions
+ 	  #ifdef VERBOSE_OUT
+ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+ 	  #endif
              dsNew = new StorageDistributionSet;
              dsNew->sz = d->sz;
              dsNew->thr = 0;
***************
*** 1211,1223 ****
--- 1488,1517 ----
      {
          StorageDistribution *dNew;
  
+ 	#ifdef LOG_OUT
+ 	auto startTime = std::chrono::steady_clock::now();
+ 	#endif
          // Compute throughput and storage dependencies
          execStorageDistribution(d);
+ 	#ifdef LOG_OUT
+ 	auto endTime = std::chrono::steady_clock::now();
+ 	std::chrono::duration<double, milli> execTime = endTime - startTime; // duration of individual execution
+ 	cumulativeTime += execTime;
+ 	#endif
+ 	#ifdef VERBOSE_OUT
+ 	computation_counter++;
+ 	#endif
  
          // Throughput of d larger then current maximum of the set
          if (d->thr > ds->thr)
              ds->thr = d->thr;
  
+ 	#ifdef LOG_OUT
+ 	// log execution times (cont. from execStorageDistribution)
+ 	dseLog << execTime.count() << ","
+ 	       << cumulativeTime.count() << endl;
+ 	#endif
+ 
          // Create new storage distributions for every channel which
          // has a storage dependency in d
          for (uint c = 0; c < g->nrChannels(); c++)
***************
*** 1225,1234 ****
              // Channel c has storage dependency?
              if (d->dep[c])
              {
                  // Do not enlarge the channel if its a self-edge
                  if (g->getChannel(c)->getSrcActor()->getId()
!                     == g->getChannel(c)->getDstActor()->getId())
!                     continue;
  
                  // Create new storage distribution with channel c enlarged
                  dNew = newStorageDistribution();
--- 1519,1535 ----
              // Channel c has storage dependency?
              if (d->dep[c])
              {
+ 	      #ifdef VERBOSE_OUT
+ 	      cout << "\tFound storage dependency in channel " << g->getChannel(c)->getName() << endl;
+ 	      #endif
                  // Do not enlarge the channel if its a self-edge
                  if (g->getChannel(c)->getSrcActor()->getId()
!                     == g->getChannel(c)->getDstActor()->getId()) {
! 		  #ifdef VERBOSE_OUT
! 		  cout << "\t\tChannel " << g->getChannel(c)->getName() << " is a self-edge: ignoring" << endl;
! 		  #endif
! 		  continue;
! 		}
  
                  // Create new storage distribution with channel c enlarged
                  dNew = newStorageDistribution();
***************
*** 1237,1249 ****
                  for (uint i = 0; i < g->nrChannels(); i++)
                  {
                      dNew->sp[i] = d->sp[i];
!                     if (i == c)
!                         dNew->sp[i] += minSzStep[c];
                  }
                  dNew->next = NULL;
                  dNew->prev = NULL;
  
                  // Add storage distribution to set of distributions to be checked
                  if (!addStorageDistributionToChecklist(dNew))
                  {
                      // Distribution already in check list
--- 1538,1558 ----
                  for (uint i = 0; i < g->nrChannels(); i++)
                  {
                      dNew->sp[i] = d->sp[i];
!                     if (i == c) {
! 		      dNew->sp[i] += minSzStep[c];
! 		      #ifdef VERBOSE_OUT
! 		      cout << "\t\tIncreasing channel size of " << g->getChannel(c)->getName()
! 			   << " to " << dNew->sp[i] << endl;
! 		      #endif
! 		    }
                  }
                  dNew->next = NULL;
                  dNew->prev = NULL;
  
                  // Add storage distribution to set of distributions to be checked
+ 		#ifdef VERBOSE_OUT
+ 		cout << "\tUpdating checklist with new storage distribution..." << endl;
+ 		#endif
                  if (!addStorageDistributionToChecklist(dNew))
                  {
                      // Distribution already in check list
***************
*** 1267,1272 ****
--- 1576,1584 ----
          d = ds->distributions;
          while (d != NULL)
          {
+ 	  #ifdef VERBOSE_OUT
+ 	  cout << "\nExploring new storage distribution:" << endl;
+ 	  #endif
              // Explore distribution d
              exploreStorageDistribution(ds, d);
  
***************
*** 1275,1280 ****
--- 1587,1596 ----
          }
  
          // Remove all non-minimal storage distributions from the set
+ 	#ifdef VERBOSE_OUT
+ 	cout << "\tTrying to minimise set with distribution size: "
+ 	     << ds->sz << endl;
+ 	#endif
          minimizeStorageDistributionsSet(ds);
      }
  
***************
*** 1305,1310 ****
--- 1621,1637 ----
          // Check sets of storage distributions till no distributions left to check,
          // or throughput bound exceeded, or maximal throughput reached
          ds = minStorageDistributions;
+ 
+ 	// Initialise log file
+ 	#ifdef LOG_OUT
+ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
+ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
+ 	       << endl; // initialise headers
+ 	#endif
+ 
+ 	#ifdef VERBOSE_OUT
+ 	cout << "DSE BEGIN:" << endl;
+ 	#endif
          while (ds != NULL)
          {
              // Explore all distributions with size 'ds->sz'
***************
*** 1390,1395 ****
--- 1717,1793 ----
              for (uint c = 0; c < g->nrChannels(); c++)
                  minStorageDistributions->distributions->sp[c] = 0;
          }
+ 
+ 	// close log file
+ 	#ifdef LOG_OUT
+ 	dseLog.close();
+ 	#endif
+ 	
+ 	// print DSE results
+ 	#ifdef VERBOSE_OUT
+ 	long int pp_counter = 0;
+ 	cout << "\nDSE RESULTS [START] (target throughput: " << maxThroughput
+ 	     << "):" << endl;
+ 
+ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+ 	     p = p->next) {
+ 	  cout << "Printing storage distributions of distribution size: "
+ 	       << p->sz << endl;
+ 	  for (StorageDistribution *d = p->distributions; d != NULL;
+ 	       d = d->next) {
+ 	    pp_counter++;
+ 	    cout << "\tCurrent StorageDistribution info:" << endl;
+ 	    cout << "\tNumber of edges: " << g->nrChannels() << endl;
+ 	    cout << "\tChannel quantities:\n\t";
+ 	    for (uint c = 0; c < g->nrChannels(); c++) {
+ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
+ 		  g->getChannel(c)->getDstActor()->getId()) {
+ 		cout << d->sp[g->getChannel(c)->getId()] << " ";
+ 	      }
+ 	    }
+ 	    cout << endl;
+ 	    cout << "\tDistribution size: " << d->sz << endl;
+ 	    cout << "\tThroughput: " << d->thr << endl;
+ 	  }
+ 	}
+ 	cout << "DSE RESULTS [END]" << endl;
+ 	cout << "Done with search!" << endl;
+ 	cout << "Number of computations: " << computation_counter << endl;
+ 	cout << "Number of pareto points: " << pp_counter << endl;
+ 	#endif
+ 
+ 	#ifdef LOG_OUT
+ 	// Variables for pareto point logging
+ 	ofstream ppLog;
+ 	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
+ 	// Initialise log file
+ 	ppLog << "storage distribution size,throughput,channel quantities" << endl;
+ 	
+ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+ 	     p = p->next) {
+ 	  for (StorageDistribution *d = p->distributions; d != NULL;
+ 	       d = d->next) {
+ 	    string output("\"");
+ 	    string delim("");
+ 	    uint noFeedbackSize = 0;
+ 	    for (uint c = 0; c < g->nrChannels(); c++) {
+ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
+ 		  g->getChannel(c)->getDstActor()->getId()) {
+ 		output += delim;
+ 		output += to_string(d->sp[g->getChannel(c)->getId()]);
+ 		delim = ",";
+ 		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
+ 	      }
+ 	    }
+ 	    output += "\"";
+ 	    ppLog << noFeedbackSize << ","
+ 		  << d->thr << ","
+ 		  << output << endl;
+ 	  }
+ 	}
+ 	ppLog.close();
+ 	#endif
+ 
      }
  
      /**
***************
*** 1409,1414 ****
--- 1807,1815 ----
          minStorageDistributions = NULL;
  
          // Initialize bounds on the search space
+         #ifdef VERBOSE_OUT
+ 	cout << "INITIALISING SEARCH PARAMETERS:" << endl;
+         #endif
          initBoundsSearchSpace(g);
  
          // Create a transition system
Only in sdf3/sdf3/csdf/analysis/buffersizing: buffer.cc~
diff -crB ../sdf3/sdf3/csdf/analysis/throughput/selftimed_throughput.cc sdf3/sdf3/csdf/analysis/throughput/selftimed_throughput.cc
*** ../sdf3/sdf3/csdf/analysis/throughput/selftimed_throughput.cc	2014-07-24 12:16:04.000000000 +0800
--- sdf3/sdf3/csdf/analysis/throughput/selftimed_throughput.cc	2021-01-22 14:11:41.872482013 +0800
***************
*** 38,44 ****
  
  namespace CSDF
  {
!     //#define _PRINT_STATESPACE
  
      /******************************************************************************
       * State
--- 38,44 ----
  
  namespace CSDF
  {
!   //#define _PRINT_STATESPACE
  
      /******************************************************************************
       * State
***************
*** 239,245 ****
              // Time between previous state
              time += s.glbClk;
          }
! 
          return (TDtime)(nr_fire) / (time);
      }
  
--- 239,246 ----
              // Time between previous state
              time += s.glbClk;
          }
!         // cout << "total number execs: " << nr_fire
!         //      << " total time: " << time << endl;
          return (TDtime)(nr_fire) / (time);
      }
  
***************
*** 523,529 ****
                          if (repCnt == outputActorRepCnt)
                          {
  #ifdef _PRINT_STATESPACE
!                             printState(currentState, cout);
  #endif
                              // Add state to hash of visited states
                              if (!storeState(currentState, recurrentState))
--- 524,530 ----
                          if (repCnt == outputActorRepCnt)
                          {
  #ifdef _PRINT_STATESPACE
!                             currentState.print(cout);
  #endif
                              // Add state to hash of visited states
                              if (!storeState(currentState, recurrentState))
diff -crB ../sdf3/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc sdf3/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc
*** ../sdf3/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc	2014-07-24 12:16:04.000000000 +0800
--- sdf3/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc	2020-12-17 17:24:41.331274360 +0800
***************
*** 360,367 ****
  
          // Measure execution time
          stopTimer(&timer);
!         out << "analysis time: ";
!         printTimer(out, &timer);
          out << endl;
      }
  
--- 360,367 ----
  
          // Measure execution time
          stopTimer(&timer);
!         // out << "analysis time: ";
!         // printTimer(out, &timer);
          out << endl;
      }
  
Only in sdf3/sdf3: data
diff -crB ../sdf3/sdf3/sdf/analysis/buffersizing/buffer.cc sdf3/sdf3/sdf/analysis/buffersizing/buffer.cc
*** ../sdf3/sdf3/sdf/analysis/buffersizing/buffer.cc	2014-07-24 12:16:04.000000000 +0800
--- sdf3/sdf3/sdf/analysis/buffersizing/buffer.cc	2021-01-21 15:28:09.061685107 +0800
***************
*** 38,46 ****
  #include "buffer.h"
  #include "../../base/algo/repetition_vector.h"
  #include "../throughput/throughput.h"
! 
  namespace SDF
  {
      /******************************************************************************
       * Bounds on the search space
       *****************************************************************************/
--- 38,57 ----
  #include "buffer.h"
  #include "../../base/algo/repetition_vector.h"
  #include "../throughput/throughput.h"
! // libraries for data logging
! #include <chrono>
! #include <string>
! #define LOG_OUT // log data of DSE in CSVs
  namespace SDF
  {
+   // variables for data logging
+ #ifdef LOG_OUT
+   std::string dirName = std::getenv("SDF3LOGDIR");
+   std::string logDirName = "dse_logs/";
+   std::string ppDirName = "pp_logs/";
+   ofstream dseLog; // save search path data in DSE log
+   std::chrono::duration<double, std::milli> cumulativeTime;
+ #endif
      /******************************************************************************
       * Bounds on the search space
       *****************************************************************************/
***************
*** 957,962 ****
--- 968,994 ----
          //for (uint c = 0; c < g->nrChannels(); c++)
          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
          //cerr << endl;
+ #ifdef LOG_OUT
+ 	// log dse data
+ 	std::string output("\"");
+ 	std::string delim("");
+ 	uint noFeedbackSize = 0;
+ 	for (SDFchannelsIter iter = g->channelsBegin();
+ 	     iter != g->channelsEnd(); iter++) {
+ 	  SDFchannel *c = *iter;
+ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+ 	    output += delim;
+ 	    output += std::to_string(d->sp[c->getId()]);
+ 	    delim = ",";
+ 	    noFeedbackSize += d->sp[c->getId()];
+ 	  }
+ 	}
+ 	output += "\"";
+ 
+ 	dseLog << noFeedbackSize << "," // distribution size
+ 	       << d->thr << "," // throughput
+ 	       << output << ","; // channel quantities
+ #endif
      }
  
      /**
***************
*** 1152,1165 ****
          StorageDistributionSet *ds, StorageDistribution *d)
      {
          StorageDistribution *dNew;
! 
          // Compute throughput and storage dependencies
          execStorageDistribution(d);
  
          // Throughput of d larger then current maximum of the set
          if (d->thr > ds->thr)
              ds->thr = d->thr;
  
          // Create new storage distributions for every channel which
          // has a storage dependency in d
          for (uint c = 0; c < g->nrChannels(); c++)
--- 1184,1210 ----
          StorageDistributionSet *ds, StorageDistribution *d)
      {
          StorageDistribution *dNew;
! #ifdef LOG_OUT
! 	auto startTime = std::chrono::steady_clock::now();
! #endif
          // Compute throughput and storage dependencies
          execStorageDistribution(d);
+ #ifdef LOG_OUT
+ 	auto endTime = std::chrono::steady_clock::now();
+ 	std::chrono::duration<double, std::milli> execTime = endTime - startTime; // duration of individual execution
+ 	cumulativeTime += execTime;
+ #endif
  
          // Throughput of d larger then current maximum of the set
          if (d->thr > ds->thr)
              ds->thr = d->thr;
  
+ #ifdef LOG_OUT
+ 	// log execution times (cont. from execStorageDistribution)
+ 	dseLog << execTime.count() << ","
+ 	       << cumulativeTime.count() << endl;
+ #endif
+ 
          // Create new storage distributions for every channel which
          // has a storage dependency in d
          for (uint c = 0; c < g->nrChannels(); c++)
***************
*** 1247,1252 ****
--- 1292,1303 ----
          // Check sets of storage distributions till no distributions left to check,
          // or throughput bound exceeded, or maximal throughput reached
          ds = minStorageDistributions;
+         // Initialise log file
+ #ifdef LOG_OUT
+ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
+ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
+ 	       << endl; // initialise headers
+ #endif
          while (ds != NULL)
          {
              // Explore all distributions with size 'ds->sz'
***************
*** 1332,1337 ****
--- 1383,1421 ----
              for (uint c = 0; c < g->nrChannels(); c++)
                  minStorageDistributions->distributions->sp[c] = 0;
          }
+         // close log file
+ #ifdef LOG_OUT
+ 	dseLog.close();
+ 	// Variables for pareto point logging
+ 	ofstream ppLog;
+ 	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
+ 	// Initialise log file
+ 	ppLog << "storage distribution size,throughput,channel quantities" << endl;
+ 
+ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+ 	     p = p->next) {
+ 	  for (StorageDistribution *d = p->distributions; d != NULL;
+ 	       d = d->next) {
+ 	    std::string output("\"");
+ 	    std::string delim("");
+ 	    uint noFeedbackSize = 0;
+ 	    for (uint c = 0; c < g->nrChannels(); c++) {
+ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
+ 		  g->getChannel(c)->getDstActor()->getId()) {
+ 		output += delim;
+ 		output += std::to_string(d->sp[g->getChannel(c)->getId()]);
+ 		delim = ",";
+ 		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
+ 	      }
+ 	    }
+ 	    output += "\"";
+ 	    ppLog << noFeedbackSize << ","
+ 		  << d->thr << ","
+ 		  << output << endl;
+ 	  }
+ 	}
+ 	ppLog.close();
+ #endif
      }
  
      /**
Only in sdf3/sdf3: vanchi_test
